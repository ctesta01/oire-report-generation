source('header.R')
source('questions.R')
source('link_responses_to_questions.R')
source('delete_trash_questions.R')
mtcars
mtcars[,1]
mtcars[,0]
help(mtcars)
warpbreaks
warpbreaks[seq(1,54,3),]
?seq
?str
str(warpbreaks)
str(survey)
# loading necessary libraries
# loading necessary libraries
library('rjson')
library('memisc')
library('gdata')
# loading survey and response data
survey = fromJSON(file='data/sample2.qsf')
responses = read.csv('data/sample2.csv', skip=2, header=F)
responses2 = read.csv('data/sample2.csv')
names(responses) = names(responses2)
rm(responses2)
# Load Header File
if(!exists("survey", mode="any")) source("header.R")
# Building "questions"
# the questions object is a copy
# of the survey$SurveyElements object, but then
# all non-question elements are removed
questions <- survey$SurveyElements
for (i in (length(questions) - 1):1) {
if (questions[[i]]$Element != "SQ") {
questions[[i]] <- NULL
}
}
# Load Header and Run Questions
if(!exists("survey", mode="any")) source("header.R")
if(!exists("questions", mode="any")) source("questions.R")
# Linking Responses to Questions
# For each question, construct a question_tag prefix which is
# it's DataExportTag + "_". For example "Q1.6" -> "Q1.6_"
# Then link responses that start with a column name that is
# either exactly the DataExportTag or start with the question_tag prefix.
# Then we build a data-frame of the matching_responses and insert
# into each question under Responses.
for (i in 1:length(questions)) {
question_tag <- paste(
questions[[i]]$Payload$DataExportTag,
"_",
sep=""
)
matching_responses <- which(
startsWith(names(responses), question_tag) |
names(responses) == questions[[i]]$Payload$DataExportTag
)
questions[[i]]$Responses <- as.data.frame(responses[matching_responses])
rm(question_tag)
}
# Load Header and Run Questions
if(!exists("survey", mode="any")) source("header.R")
if(!exists("questions", mode="any")) source("questions.R")
# Get the Block element from the survey$SurveyElements list
Blocks <- Filter(function(x) x$Element == "BL", survey$SurveyElements)
# As far as I can tell, there's only one Block element in the
# survey$SurveyElements list. In that Block element, there's multiple
# payloads. So here I'm checking for which payload of the payloads in
# the single Block element found have the type "Trash"
# NOTE: It might not be true that there's only one Block element, if there
# are more, this will have to be re-done.
Trash <- Filter(function(x) x$Type == "Trash", Blocks[[1]]$Payload)
TrashQuestions <- list()
for (i in Trash[[1]]$BlockElements) {
TrashQuestions <- c(i$QuestionID, TrashQuestions)
}
delete_if_in_trash <- function(x) if (x$Payload$QuestionID %in% TrashQuestions) {
return(NULL)
} else {
return(x)
}
# replace any questions that are in the trash with NULL in the questions list
# and then delete all the questions equal to NULL
questions <- lapply(questions, delete_if_in_trash)
questions <- Filter(Negate(function(x) is.null(unlist(x))), questions)
# clearing out the variables we don't need anymore
rm(delete_if_in_trash)
rm(Blocks)
rm(Trash)
rm(TrashQuestions)
mydat <- edit(data.frame())
